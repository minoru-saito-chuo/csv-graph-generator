<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>複数データセットグラフ描画ツール (X-Yペア・高機能・サイズ指定・入力順・ラベル編集版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        #chart-container {
            position: relative;
            width: 100%; 
            height: 60vh; 
            min-height: 300px; 
            max-width: 100%; 
        }
        input[type="file"]::file-selector-button {
            margin-right: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            border-width: 0px;
            font-size: 0.875rem; 
            font-weight: 600; 
            background-color: #EBF8FF; 
            color: #2B6CB0; 
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #BEE3F8; 
        }
        .toggle-checkbox:checked + .toggle-label .toggle-dot {
            transform: translateX(100%);
            background-color: #4A5568; 
        }
        .toggle-checkbox:checked + .toggle-label .toggle-bg {
            background-color: #A0AEC0; 
        }
    </style>
</head>
<body class="bg-gray-100 font-sans p-4 sm:p-8">
    <div class="container mx-auto max-w-5xl bg-white shadow-xl rounded-lg p-6">
        <header class="mb-6">
            <h1 class="text-2xl sm:text-3xl font-bold text-center text-gray-700">複数データセットグラフ描画ツール</h1>
        </header>

        <section id="input-section" class="mb-6 grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <h2 class="text-lg sm:text-xl font-semibold text-gray-600 mb-2">1. CSVデータをテキストエリアに入力:</h2>
                <textarea id="csv-input" class="w-full h-48 p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="例:\nデータ1X,データ1Y,データ2X,データ2Y\n1,10,1.1,100\n2,12,2.2,120\n3,15, , \n ,  ,3.3,150\n4,18,4.0,175"></textarea>
                <button id="add-data-text-btn" class="mt-2 w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">テキストエリアからデータを追加</button>
            </div>
            <div>
                <h2 class="text-lg sm:text-xl font-semibold text-gray-600 mb-2">2. またはCSVファイルをアップロード:</h2>
                <input type="file" id="file-input" accept=".csv" class="w-full p-1 sm:p-2 border border-gray-300 rounded-md text-sm">
                <p class="text-xs text-gray-500 mt-1">ファイルを選択すると自動的にデータが追加されます。</p>
            </div>
        </section>

        <section id="chart-options-section" class="mb-6 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4 items-end">
            <div>
                <label for="x-axis-label-input" class="block text-sm font-medium text-gray-700">X軸ラベル:</label>
                <input type="text" id="x-axis-label-input" value="X軸" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
            </div>
            <div>
                <label for="y-axis-label-input" class="block text-sm font-medium text-gray-700">Y軸ラベル:</label>
                <input type="text" id="y-axis-label-input" value="Y軸" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
            </div>
            <div>
                <label for="chart-width-input" class="block text-sm font-medium text-gray-700">グラフ幅 (px):</label>
                <input type="number" id="chart-width-input" placeholder="デフォルト" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
            </div>
            <div>
                <label for="chart-height-input" class="block text-sm font-medium text-gray-700">グラフ高さ (px):</label>
                <input type="number" id="chart-height-input" placeholder="デフォルト (min 300)" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
            </div>
            <div class="mt-1 sm:mt-5">
                <label for="mode-toggle" class="flex items-center cursor-pointer">
                    <span class="mr-2 text-sm font-medium text-gray-700">モード:</span>
                    <div class="relative">
                        <input type="checkbox" id="mode-toggle" class="sr-only toggle-checkbox">
                        <div class="toggle-label block w-14 h-8 rounded-full toggle-bg bg-blue-500">
                            <div class="toggle-dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full shadow-md transition-transform duration-300 ease-in-out"></div>
                        </div>
                    </div>
                    <span id="mode-label" class="ml-3 text-sm font-medium text-gray-700">カジュアル</span>
                </label>
            </div>
        </section>

        <section id="series-label-editor-section" class="mb-6">
            <h3 class="text-lg font-semibold text-gray-600 mb-2">系列ラベル編集:</h3>
            <div id="series-labels-container" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                </div>
        </section>

         <button id="update-options-btn" class="mb-6 w-full bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">オプションをグラフに反映</button>

        <section id="controls-section" class="mb-6 grid grid-cols-1 sm:grid-cols-2 gap-4">
            <button id="save-chart-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">グラフを画像で保存 (PNG)</button>
            <button id="clear-chart-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">全データとグラフをクリア</button>
        </section>

        <section id="message-area" class="mb-4 p-3 rounded-md hidden">
            <p id="message-text"></p>
        </section>

        <section id="chart-wrapper" class="overflow-x-auto"> 
            <div id="chart-container" class="bg-white p-1 sm:p-4 rounded-lg shadow-inner border border-gray-200 mx-auto"> 
                <canvas id="myChart"></canvas>
            </div>
        </section>

        <footer class="mt-8 text-center text-sm text-gray-500">
            <p>© 2025 SAITO Minoru.</p>
        </footer>
    </div>

    <script>
        // DOM要素の取得
        const csvInput = document.getElementById('csv-input');
        const addDataTextButton = document.getElementById('add-data-text-btn');
        const fileInput = document.getElementById('file-input');
        const clearChartButton = document.getElementById('clear-chart-btn');
        const saveChartButton = document.getElementById('save-chart-btn');
        const chartCanvas = document.getElementById('myChart');
        const chartContainer = document.getElementById('chart-container');
        const messageArea = document.getElementById('message-area');
        const messageText = document.getElementById('message-text');
        const xAxisLabelInput = document.getElementById('x-axis-label-input');
        const yAxisLabelInput = document.getElementById('y-axis-label-input');
        const chartWidthInput = document.getElementById('chart-width-input');
        const chartHeightInput = document.getElementById('chart-height-input');
        const updateOptionsButton = document.getElementById('update-options-btn');
        const modeToggle = document.getElementById('mode-toggle');
        const modeLabel = document.getElementById('mode-label');
        const seriesLabelsContainer = document.getElementById('series-labels-container');

        // グローバル変数
        let chartInstance = null;
        let allChartDatasets = []; 
        let isFormalMode = false; 
        
        // スタイル定義
        const casualColors = [
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
            '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'
        ];
        const formalColors = ['#000000', '#555555', '#777777', '#999999', '#BBBBBB', '#333333', '#666666', '#888888', '#AAAAAA'];
        const formalPointStyles = ['circle', 'rect', 'triangle', 'rectRot', 'star', 'cross', 'dash', 'crossRot', 'line'];

        // --- イベントリスナー ---
        addDataTextButton.addEventListener('click', () => {
            const csvString = csvInput.value.trim();
            if (csvString) {
                processAndAddData(csvString, "テキストエリア");
            } else {
                showMessage("テキストエリアにCSVデータを入力してください。", 'error');
            }
        });

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    processAndAddData(e.target.result, file.name);
                };
                reader.onerror = () => {
                    showMessage(`ファイル読み取りエラー: ${file.name}`, 'error');
                }
                reader.readAsText(file);
                fileInput.value = null;
            }
        });
        
        modeToggle.addEventListener('change', () => {
            isFormalMode = modeToggle.checked;
            modeLabel.textContent = isFormalMode ? "フォーマル" : "カジュアル";
        });
        
        updateOptionsButton.addEventListener('click', () => { 
            if (chartInstance) {
                // グラフサイズの更新
                const newWidth = chartWidthInput.value;
                const newHeight = chartHeightInput.value;
                chartContainer.style.width = newWidth ? `${newWidth}px` : '100%'; 
                chartContainer.style.height = newHeight ? `${Math.max(300, parseInt(newHeight))}px` : '60vh'; 

                // 軸ラベルの更新
                chartInstance.options.scales.x.title.text = xAxisLabelInput.value || "X軸";
                chartInstance.options.scales.y.title.text = yAxisLabelInput.value || "Y軸";
                
                // 系列ラベルの更新
                updateSeriesLabelsFromUI();

                // スタイルの更新
                updateDatasetStyles(); 
                
                chartInstance.update(); 
                showMessage("グラフオプションが反映されました。", "success");
            } else {
                showMessage("グラフが描画されていません。データを追加すると現在の設定で描画されます。", "info");
            }
        });

        clearChartButton.addEventListener('click', () => {
            if (chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }
            allChartDatasets = [];
            csvInput.value = "";
            xAxisLabelInput.value = "X軸";
            yAxisLabelInput.value = "Y軸";
            chartWidthInput.value = ""; 
            chartHeightInput.value = "";
            chartContainer.style.width = '100%'; 
            chartContainer.style.height = '60vh';
            modeToggle.checked = false; 
            isFormalMode = false;
            modeLabel.textContent = "カジュアル";
            seriesLabelsContainer.innerHTML = ''; // 系列ラベル編集UIをクリア
            showMessage("グラフと全データがクリアされました。", 'info');
        });

        saveChartButton.addEventListener('click', () => {
            if (chartInstance) {
                const imageURL = chartInstance.toBase64Image('image/png', 1.0);
                const link = document.createElement('a');
                link.href = imageURL;
                link.download = 'chart.png';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showMessage("グラフがPNG画像として保存されました。", 'success');
            } else {
                showMessage("保存するグラフがありません。データを追加してグラフを描画してください。", 'error');
            }
        });

        // --- メッセージ表示関数 ---
        function showMessage(message, type = 'info') {
            if (!message) {
                messageArea.classList.add('hidden');
                return;
            }
            messageText.textContent = message;
            messageArea.classList.remove('hidden');
            messageArea.className = 'mb-4 p-3 rounded-md border-l-4';

            if (type === 'error') {
                messageArea.classList.add('bg-red-100', 'border-red-500', 'text-red-700');
            } else if (type === 'success') {
                messageArea.classList.add('bg-green-100', 'border-green-500', 'text-green-700');
            } else {
                messageArea.classList.add('bg-blue-100', 'border-blue-500', 'text-blue-700');
            }
        }
        
        // --- CSVパースとデータ追加処理 ---
        function processAndAddData(csvString, sourceName) {
            showMessage("", ""); 
            const result = parseCSVData(csvString); 
            if (result.error) {
                showMessage(`エラー (${sourceName}): ${result.error}`, 'error');
                return;
            }
            // 新しいデータセットにユニークIDを付与 (ラベル編集のため)
            result.datasets.forEach((ds, index) => {
                ds.id = `dataset-${Date.now()}-${allChartDatasets.length + index}`;
            });

            allChartDatasets.push(...result.datasets); 
            if (allChartDatasets.length > 0) {
                renderChart(); 
                populateSeriesLabelEditor(); // 系列ラベル編集UIを生成
                showMessage(`${sourceName} から ${result.datasets.length} 個のデータセットが追加されました。合計 ${allChartDatasets.length} 個のデータセットがあります。`, 'success');
            } else {
                showMessage("追加する有効なデータが見つかりませんでした。", 'error');
            }
        }
        
        // --- 系列ラベル編集UI生成 ---
        function populateSeriesLabelEditor() {
            seriesLabelsContainer.innerHTML = ''; // 既存のUIをクリア
            if (!chartInstance || !chartInstance.data.datasets) return;

            chartInstance.data.datasets.forEach((dataset, index) => {
                const div = document.createElement('div');
                div.className = 'flex items-center space-x-2';
                
                const currentLabelSpan = document.createElement('span');
                currentLabelSpan.className = 'text-sm text-gray-600 truncate';
                currentLabelSpan.textContent = `${dataset.label || `系列 ${index + 1}`}:`;
                currentLabelSpan.title = dataset.label || `系列 ${index + 1}`;

                const input = document.createElement('input');
                input.type = 'text';
                input.value = dataset.label || '';
                input.setAttribute('data-dataset-id', dataset.id || `chartjs-dataset-${index}`); // dataset.id を使う
                input.className = 'series-label-input mt-1 block w-full p-1 border border-gray-300 rounded-md shadow-sm sm:text-sm focus:ring-indigo-500 focus:border-indigo-500';
                input.placeholder = `系列 ${index + 1} ラベル`;

                div.appendChild(currentLabelSpan);
                div.appendChild(input);
                seriesLabelsContainer.appendChild(div);
            });
        }

        // --- UIから系列ラベルを更新 ---
        function updateSeriesLabelsFromUI() {
            if (!chartInstance || !chartInstance.data.datasets) return;
            const inputs = seriesLabelsContainer.querySelectorAll('.series-label-input');
            inputs.forEach(input => {
                const datasetId = input.getAttribute('data-dataset-id');
                // allChartDatasets と chartInstance.data.datasets の両方を更新する必要があるかもしれない
                // ここでは chartInstance の直接編集を試みる
                const targetDataset = chartInstance.data.datasets.find(ds => (ds.id || `chartjs-dataset-${chartInstance.data.datasets.indexOf(ds)}`) === datasetId);
                if (targetDataset) {
                    targetDataset.label = input.value || targetDataset.label; // 空なら元のラベル維持
                }
                // allChartDatasets も更新 (永続化のため)
                const originalDataset = allChartDatasets.find(ds => ds.id === datasetId);
                if (originalDataset) {
                    originalDataset.label = input.value || originalDataset.label;
                }
            });
        }


        // --- データセットのスタイルを更新する関数 ---
        function updateDatasetStyles() {
            if (!chartInstance || !chartInstance.data.datasets) return;
            let colorPaletteIndex = 0;
            let formalStylePaletteIndex = 0;
            chartInstance.data.datasets.forEach((dataset) => {
                let color, pointStyle, pointBackgroundColor;
                if (isFormalMode) {
                    color = formalColors[formalStylePaletteIndex % formalColors.length];
                    pointStyle = formalPointStyles[formalStylePaletteIndex % formalPointStyles.length];
                    pointBackgroundColor = color; 
                    dataset.pointRadius = 3; 
                    dataset.pointHoverRadius = 5; 
                    formalStylePaletteIndex++;
                } else {
                    color = casualColors[colorPaletteIndex % casualColors.length];
                    pointStyle = 'circle'; 
                    pointBackgroundColor = colorWithAlpha(color, 0.5); 
                    dataset.pointRadius = 4; 
                    dataset.pointHoverRadius = 6;
                    colorPaletteIndex++;
                }
                dataset.borderColor = color;
                dataset.backgroundColor = pointBackgroundColor; 
                dataset.pointStyle = pointStyle;
                dataset.borderWidth = 2;
                dataset.tension = 0.1; 
                dataset.fill = false;
                dataset.showLine = true;
            });
        }

        function colorWithAlpha(hexColor, alpha) {
            if (!hexColor || !hexColor.startsWith('#')) return `rgba(0,0,0,${alpha})`; 
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // --- CSVデータ解析関数 ---
        function parseCSVData(csvString) {
            const lines = csvString.trim().split('\n').filter(line => line.trim() !== '');
            if (lines.length < 2) {
                return { error: "CSVデータにはヘッダー行と少なくとも1つのデータ行が必要です。" };
            }
            const header = lines[0].split(',').map(h => h.trim());
            if (header.length === 0 || header.length % 2 !== 0) {
                return { error: "CSVヘッダーの列数は偶数である必要があります（X軸列名, Y軸列名のペア）。" };
            }
            const numDatasets = header.length / 2;
            const newDatasets = [];
            for (let k = 0; k < numDatasets; k++) {
                const xHeader = header[2 * k];
                const yHeader = header[2 * k + 1];
                let datasetLabel = yHeader; 
                const yMatch = yHeader.match(/(.*)のY軸/i) || yHeader.match(/(.*)_Y$/i) || yHeader.match(/(.*)Y$/i) ;
                const xMatch = xHeader.match(/(.*)のX軸/i) || xHeader.match(/(.*)_X$/i) || xHeader.match(/(.*)X$/i);
                if (yMatch && yMatch[1]) {
                    datasetLabel = yMatch[1].trim();
                } else if (xMatch && xMatch[1]) {
                    datasetLabel = xMatch[1].trim();
                } else if (yHeader.toLowerCase().startsWith(xHeader.toLowerCase() + "_y")) { 
                     datasetLabel = xHeader;
                } else if (yHeader) {
                    datasetLabel = yHeader; 
                } else {
                    datasetLabel = `データセット ${k + 1}`; 
                }
                newDatasets.push({ label: datasetLabel, data: [] });
            }
            for (let i = 1; i < lines.length; i++) { 
                const rowValues = lines[i].split(',').map(val => val.trim());
                for (let k = 0; k < numDatasets; k++) { 
                    const xValStr = rowValues[2 * k];
                    const yValStr = rowValues[2 * k + 1];
                    if (xValStr !== undefined && xValStr !== "" && yValStr !== undefined && yValStr !== "") {
                        const xVal = parseFloat(xValStr);
                        const yVal = parseFloat(yValStr);
                        if (!isNaN(xVal) && !isNaN(yVal)) {
                            newDatasets[k].data.push({ x: xVal, y: yVal });
                        } else {
                            if ((isNaN(xVal) && xValStr !== "") || (isNaN(yVal) && yValStr !== "")) {
                                console.warn(`データ行 ${i + 1}, データセット ${k+1} (${header[2*k]}/${header[2*k+1]}): X値 '${xValStr}' または Y値 '${yValStr}' のどちらかが有効な数値ではありません。このポイントをスキップします。`);
                            }
                        }
                    }
                }
            }
            // X軸の値でのソートは行わない
            const finalDatasets = newDatasets.filter(ds => ds.data.length > 0);
            if (finalDatasets.length === 0 && newDatasets.length > 0) { 
                 return { error: "有効な数値データポイントが見つかりませんでした。" };
            }
            return { datasets: finalDatasets };
        }

        // --- グラフ描画関数 ---
        function renderChart() {
            const ctx = chartCanvas.getContext('2d');
            if (chartInstance) {
                chartInstance.destroy();
            }
            
            const newWidth = chartWidthInput.value;
            const newHeight = chartHeightInput.value;
            chartContainer.style.width = newWidth ? `${newWidth}px` : '100%';
            chartContainer.style.height = newHeight ? `${Math.max(300, parseInt(newHeight))}px` : '60vh';

            // allChartDatasets をもとに chartInstance.data.datasets を構築
            // この時点でラベルは allChartDatasets のものが使われる
            const datasetsForChart = allChartDatasets.map(ds => ({ ...ds }));


            chartInstance = new Chart(ctx, {
                type: 'line', 
                data: { datasets: datasetsForChart }, // ここで初期ラベルが設定される
                options: {
                    responsive: true,
                    maintainAspectRatio: false, 
                    scales: {
                        x: {
                            type: 'linear', 
                            position: 'bottom',
                            title: { display: true, text: xAxisLabelInput.value || "X軸", font: { size: 14, weight: 'bold' }, padding: { top: 10 } }
                        },
                        y: {
                            type: 'linear', 
                            title: { display: true, text: yAxisLabelInput.value || "Y軸", font: { size: 14, weight: 'bold' }, padding: { bottom: 10 } },
                            beginAtZero: false 
                        }
                    },
                    plugins: {
                        tooltip: {
                            mode: 'index', 
                            intersect: false, 
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || ''; // 更新されたラベルが使われる
                                    if (label) { label += ': '; }
                                    if (context.parsed.y !== null) { label += `(X: ${context.parsed.x.toFixed(2)}, Y: ${context.parsed.y.toFixed(2)})`; }
                                    return label;
                                }
                            }
                        },
                        legend: {
                            position: 'top', 
                            labels: { usePointStyle: true, padding: 20, font: { size: 12 } }
                        },
                        customCanvasBackgroundColor: { color: 'white' }
                    },
                    interaction: { mode: 'nearest', axis: 'x', intersect: false }
                },
                plugins: [{
                    id: 'customCanvasBackgroundColor',
                    beforeDraw: (chart, args, options) => {
                        if (options.color) {
                            const {ctx} = chart;
                            ctx.save();
                            ctx.globalCompositeOperation = 'destination-over';
                            ctx.fillStyle = options.color;
                            ctx.fillRect(0, 0, chart.width, chart.height);
                            ctx.restore();
                        }
                    }
                }]
            });
            updateDatasetStyles(); 
            // populateSeriesLabelEditor(); // renderChart後に呼び出すことで、chartInstanceが確実に存在するようにする
            chartInstance.update(); 
        }
        
        // 初期メッセージ
        showMessage("CSVデータを入力またはアップロードしてグラフを作成してください。\nCSV形式: データ1X列名,データ1Y列名,データ2X列名,データ2Y列名...", 'info');
        modeLabel.textContent = isFormalMode ? "フォーマル" : "カジュアル"; 

    </script>
</body>
</html>
